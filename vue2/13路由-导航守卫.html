<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue-Router</title>
<script src="https://unpkg.com/vue@2/dist/vue.js"></script>
<script src="https://unpkg.com/vue-router@3/dist/vue-router.js"></script>
</head>
<body>
  <div id="app">
    <h1>Hello App!</h1>
    <p>
      <!-- 使用 router-link 组件来导航.-->
      <!-- 通过传入 `to` 属性指定链接.-->
      <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
      <router-link to="/user/123">Go to user 123</router-link>
      <!-- 路由重命名引用 -->
      <!-- <router-link :to="{ name: 'user', params: { userId: 123 }}">Go to user 123</router-link> -->
      <router-link to="/user/456">Go to user 456</router-link>
    </p>
    <!-- 路由出口 -->
    <!-- 路由匹配到的组件将渲染在这里 -->
    <!-- 命名视图 -->
    <!-- 如果 router-view 没有设置名字，那么默认为 default -->
    <router-view></router-view>
    <router-view name="test"></router-view>
  </div>
  
</body>
<script>
  const User = {
    // 当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用
    template: `
      <div>
        <div>User {{ $route.params.id }}</div>
        <div>导航地址：<input v-model="url" /></div>
        <div>
          <input type="button" value="push" @click="routerHandle('push')"/>
          <input type="button" value="replace" @click="routerHandle('replace')"/>
          <input type="button" value="go(-1)" @click="routerHandle('go')"/>
        </div>
        <router-link :to="'/user/' + $route.params.id + '/profile'">Go to user profile</router-link>
        <router-link :to="'/user/' + $route.params.id + '/posts'">Go to user posts</router-link>
        <router-view></router-view> 
      </div>
    `,
    data: function() {
      return {
        url: '',
      }
    },
    // 两个路由都渲染同个组件(组件实例会被复用),组件的生命周期钩子不会再被调用
    mounted: function() {
      console.log('User Component mounted ！');
    },
    methods: {
      routerHandle:function(type) {
        // 编程式导航
        // 路由重命名引用
        // router.push({ name: 'user', params: { userId: 123 } })
        switch (type) {
          case 'push':
            this.$router.push(this.url);
            break;
          case 'replace':
            this.$router.replace(this.url);
            break;
          case 'go':
            this.$router.go(-1);
            break;
          default: break;
        }
      }
    },
    watch: {
      // 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象
      $route(to, from) {
        console.log("$route --> to, from:", to, from)
      }
    }
  }

  const UserProfile = { template: '<div>UserProfile</div>'}
  const UserPosts = { template: '<div>UserPosts</div>'}
  const Test = {
    props: ['id'],
    template: '<div>Test: {{ id }}</div>',
  }

  const NotFound = {
    template: '<h1>404 not found</h1>',
    // 组件内的守卫
    beforeRouteEnter(to, from, next) {
      // 在渲染该组件的对应路由被 confirm 前调用
      // 不！能！获取组件实例 `this`
      // 因为当守卫执行前，组件实例还没被创建
      next(vm => {
        // 通过 `vm` 访问组件实例
      })
    },
    beforeRouteUpdate(to, from, next) { // (2.2 新增)
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例 `this`
      this.name = to.params.name
      next()
    },
    beforeRouteLeave(to, from, next) {
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例 `this`
      // 离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消
      const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
      if (answer) {
        next()
      } else {
        next(false)
      }
    },
    watch: {
      // 当使用一个通配符时，$route.params 内会自动添加一个名为 pathMatch 参数。它包含了 URL 通过通配符被匹配的部分
      $route(to, from) {
        console.log("$route --> to.params.pathMatch:", to.params.pathMatch)
      }
    }
  }

  const router = new VueRouter({
    // vue-router 默认 hash 模式
    mode: 'history',
    // 匹配的优先级就按照路由的定义顺序：路由定义得越早，优先级就越高。
    routes: [
      {
        path: '/',
        // 重定向
        redirect: '/user/test',
        // 别名
        // “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL
        alias: '/renameUrl',
        // 路由独享的守卫
        beforeEnter: (to, from, next) => {
          // ...
        }
      },
      // 动态路径参数 以冒号开头
      { 
        path: '/user/:id', 
        name: 'user',
        components: {
          default: User,
          test: Test,
        },
        // 如果 props 被设置为 true，route.params 将会被设置为组件属性。
        props: {
          default: false,
          test: true,
        },
        children: [
        {
          // 当 /user/:id/profile 匹配成功，
          // UserProfile 会被渲染在 User 的 <router-view> 中
          path: 'profile',
          component: UserProfile
        },
        {
          // 当 /user/:id/posts 匹配成功
          // UserPosts 会被渲染在 User 的 <router-view> 中
          path: 'posts',
          component: UserPosts
        }
      ]
      },
        // 会匹配以 `/user-` 开头的任意路径
      { path: '/user-*' },
      // 会匹配所有路径
      // 放在最后,通常用于客户端 404 错误
      { path: '*', component: NotFound },
    ]
  })

  // 全局前置守卫
  router.beforeEach((to, from, next) => {
    // 每个守卫方法接收三个参数：
    // to: Route: 即将要进入的目标 路由对象
    // from: Route: 当前导航正要离开的路由
    //  next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。
    //  next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。
    //  next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。
    //  next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。
    //  next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。
    // 确保 next 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。
    if(to.userId) next();
    else next('/login');
  })

  // 全局解析守卫
  // 在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

  // 全局后置钩子
  // 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身
  router.afterEach((to, from) => {
    // ...
  })


  // 4.创建和挂载根实例。
  // 记得要通过 router 配置参数注入路由，
  // 从而让整个应用都有路由功能
  new Vue({
    router,
  }).$mount('#app')
</script>
</html>

<!-- 完整的导航解析流程
1.导航被触发。
2.在失活的组件里调用 beforeRouteLeave守卫。
3.调用全局的 beforeEach 守卫。
4.在重用的组件里调用 beforeRouteUpdate 守卫（2.2+）。
5.在路由配置里调用 beforeEnter。
6.解析异步路由组件。
7.在被激活的组件里调用 beforeRouteEnter。
8.调用全局的 beforeResolve 守卫 （2.5+）。
9.导航被确认。
10.调用全局的afterEach 钩子。
11.触发DOM 更新。
12.调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 -->