<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 组件测试实例</title>
<script src="https://cdn.staticfile.org/vue/2.6.2/vue.min.js"></script>
</head>
<body>
<div id="app">
  <!-- 在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的 -->
  <div>childMessage is: {{ childMessage }}</div>
  <global-component message="hello world" :author="author" @sendMessage="setChildMessage"></global-component>
  <customer-component></customer-component>
  <!-- 自定义组件的 v-model 2.2.0+ -->
  <!-- 这里的 isChecked 的值将会传入这个名为 checked 的 prop。 -->
  <!-- 同时当 <base-checkbox> 触发一个 change 事件并附带一个新的值的时候，这个 isChecked 的 property 将会被更新。 -->
  <base-checkbox v-model="isChecked"></base-checkbox>
  <!-- 将原生事件绑定到组件 -->
  <!-- .native 在一个组件的根元素上直接监听一个原生事件 -->
  <base-input @focus.native="onFocus"></base-input>
  <!-- .sync 修饰符（2.3.0+） -->
  <div>sync input value: {{ inputVal }}</div>
  <sync-input v-bind:message.sync="inputVal"></sync-input>
  <!-- .sync修饰符属于下方模式的缩写 -->
  <!-- <sync-input v-bind:message="inputVal" v-on:update:message="inputVal = $event"></sync-input> -->
  <!-- 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。 -->
</div>

<script>
  // 注册全局组件
  // Vue.component(tagName, options)
  Vue.component(
    // 组件名命名
    // 使用 kebab-case 'global-component'
    // 使用 PascalCase 'GlobalComponent'
    'GlobalComponent', 
    {
      // 声明 props
      props: ['message', 'author'],
      template: `<div>
        <h3>自定义全局组件! + {{ message }} + {{ author }}</h3>
        <button @click="setChildMessage">子传父</button>
      </div>`,
      data: function() {
        return {
          myMessage: 'child is GlobalComponent!',
        }
      } ,
      methods: {
        setChildMessage: function () {
          // v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)
          // 所以 v-on:sendMessage 将会变成 v-on:sendmessage
          // 推荐始终使用 kebab-case(send-message)的事件名。
          this.$emit('sendmessage', this.myMessage);
        }
      }
    }
  )

  Vue.component('base-checkbox', {
    // 一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，
    // 但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。
    // model 选项可以用来避免这样的冲突
    model: {
      prop: 'checked',
      event: 'change'
    },
    // 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop
    props: {
      checked: Boolean
    },
    template: `
      <input
        type="checkbox"
        v-bind:checked="checked"
        v-on:change="$emit('change', $event.target.checked)"
      >
    `
  })

  Vue.component('base-input', {
    template: `
      <input
        type="text"
      >
    `
  })

  Vue.component('sync-input', {
    template: `
      <div>
        sync input: <input
          type="text"
          v-on:change="onChange"
        >
      </div>
    `,
    /*data: function() {
      return {
        value: '',
      }
    },*/
    props: ['message'],
    methods:{
      onChange: function(e) {
        this.$emit('update:message', e.target.value)
      },
    }
  })

  // 注册局部组件
  var CustomerComponent = {
    // Prop 验证
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      },
    },
    // type 可以是下面原生构造器：
    // String | Number | Boolean | Array | Object | Date | Function | Symbol | 
    // type 也可以是一个自定义构造器，使用 instanceof 检测。
    template: '<h3>自定义局部组件!</h3>',
  }

  new Vue({
    el: '#app', // 渲染跟根组件选择器名称
    components: { // 注册局部组件-注册组件将只在父模板可用
      'customer-component': CustomerComponent,
    },
    data: {
      author: 'sk',
      childMessage: '',
      isChecked: false,
      inputVal: '',
    },
    methods: {
      setChildMessage: function(val) {
        this.childMessage = val;
      },
      onFocus: function(e) {
        console.log("e:", e)
      },
    }
  })
</script>
</body>
</html>